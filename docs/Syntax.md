
# Синтаксис Bock — полный справочник

## Общая структура

```bock
function [NAME] {
    [команды];
}
```

Каждая команда заканчивается на `;`. Функции можно вкладывать логически через условия и циклы, но каждая `function` — это отдельная блок-схема.

---

## Ключевые слова

| Ключевое слово | Назначение |
|---|---|
| `function` | Объявление функции / блок-схемы |
| `input >>` | Блок ввода данных |
| `output >>` | Блок вывода данных |
| `if (условие) {}` | Условный блок |
| `else {}` | Ветка "НЕТ" условия |
| `while (условие) {}` | Цикл с предусловием |
| `for x in y {}` | Цикл `for` |
| `//` | Комментарий (не рендерится) |

---

## Переменные и выражения

```bock
x = 10;           // присвоение
x = x + 1;        // арифметика
result = a * b;   // любые выражения
```

Любая строка с `=` становится **блоком действия**. Тип данных не указывается.

---

## Ввод / Вывод

```bock
input >> "имя_переменной";
input >> "a,b,c";       // множественный ввод

output >> "значение";
output >> "a,b,c";      // множественный вывод
```

---

## Условие if / else

```bock
if (условие) {
    // ветка ДА
};
else {
    // ветка НЕТ
};
```

- Всё в `{}` рендерится **ниже** блока условия и никогда не выходит на главную линию.
- `else` — это линия **НЕТ**.
- Если `else` нет, линия НЕТ возвращается на главную линию.

---

## Цикл while

```bock
while (условие) {
    // тело цикла
};
```

- Содержимое `{}` рендерится ниже блока условия, подключено от ноды **ДА**.
- Из последнего блока тела стрелка уходит **вверх** к блоку условия.
- Следующие после цикла блоки подключены от ноды **НЕТ**.

---

## Цикл for

```bock
for x in коллекция {
    // тело цикла
};
```

- Логика рендера аналогична `while`, но блок отображается как **Цикл for** (по ГОСТ 19.701).
- Из последнего блока тела стрелка уходит вверх к блоку `for`.

---

## Вложенные конструкции

Условия и циклы можно вкладывать друг в друга. Главное — следить за правильным закрытием `{};`.

```bock
function double_if {
    a = yes;
    b = no;

    if (a = yes) {
        if (b = no) {
            output >> "both true";
        };
        else {
            output >> "only a is true";
        };
    };
    output >> "end";
}
```

---

## Важно: именование функций

Функции **могут** называться `if`, `while`, `else`, `for` и т.д. — но обязательно с префиксом `function`:

```bock
function if { ... }      // корректно
function while { ... }   // корректно
```

---

# Циклы и условия

## Условие if / else

Каждый `if` содержит два блока:
- `()` — условие, которое передаётся в **блок условия**
- `{}` — пакет ветки ДА, блоки из него всегда рендерятся **ниже** блока условия и никогда не выходят на главную линию

`else` — это ветка **НЕТ**. Её блоки тоже рендерятся ниже блока условия. Если `else` нет, линия НЕТ возвращается на главную линию.

```bock
function exp_if {
    i = 10;
    if (i = 10) {
        output >> "i = 10";
    };          // ; в конце условия обязателен
    else {
        output >> "i != 10";
    };
    // код продолжается...
}
```

### Вложенные условия

```bock
function double_if {
    a = yes;
    b = no;

    if (a = yes) {
        if (b = no) {
            output >> "2 is true";
        };
        else {
            output >> "only 1 is true";
        };
    };
    output >> "End of program";
}
```

---

## Цикл while

Содержимое `{}` рендерится ниже блока условия и подключено от ноды **ДА**. Из последнего блока тела стрелка уходит **вверх** к блоку условия. Все блоки после цикла подключены от ноды **НЕТ**.

```bock
function exp_while {
    i = 10;
    while (i != 0) {
        output >> "i";
        i = i - 1;
    };
    output >> "done";
}
```

---

## Цикл for

Логика рендера аналогична `while`, но блок отображается как **Цикл for** (согласно ГОСТ 19.701). Из последнего блока тела стрелка уходит вверх к блоку `for`.

```bock
function exp_for {
    i = 10;
    for i in something {
        output >> "i";
        i = i - 1;
    };
    output >> "done";
}
```

---

