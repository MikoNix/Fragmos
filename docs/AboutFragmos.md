# Fragmos — рендер для Bock

Fragmos — это интерпретатор, который принимает Bock-код на вход и выдаёт `block.json` с готовой топологией блок-схемы.

---

## Как работает интерпретатор

### 1. Парсинг функции

Fragmos ищет конструкцию `function [NAME] { ... }` и извлекает тело функции. Каждая функция обрабатывается независимо и компилируется в отдельный `block.json`.

### 2. Токенизация команд

Тело функции разбивается на команды по символу `;`. Отступы и переносы строк игнорируются — интерпретатору важны только разделители.

### 3. Определение типа блока

Каждая команда анализируется и превращается в блок нужного типа:

| Паттерн команды | Тип блока |
|---|---|
| `output >> ...` | `Ввод / вывод` |
| `input >> ...` | `Ввод / вывод` |
| `if (...) {...}` | `Условие` + дочерние блоки |
| `while (...) {...}` | `Условие` + дочерние блоки с обратной стрелкой |
| `for x in y {...}` | `Цикл for` + дочерние блоки |
| `x = ...` | `Блок` |

### 4. Расстановка координат

Блоки расставляются сверху вниз по главной линии. При встрече условия или цикла блоки дочерних веток смещаются вправо/влево относительно главной линии. Координаты `x`, `y` вычисляются автоматически с учётом размеров блоков и отступов.

### 5. Генерация стрелок

После расстановки блоков генерируются объекты стрелок (`arrows`). Для каждого перехода вычисляются:
- `startIndex` и `endIndex` — индексы блоков в массиве
- `startConnectorIndex` и `endConnectorIndex` — стороны подключения (0=верх, 1=право, 2=низ, 3=лево)
- `nodes` — промежуточные точки для обхода блоков при обратных стрелках (в циклах)

### 6. Начало и конец

Блоки `Начало` и `Конец` добавляются автоматически в начало и конец каждой функции.

---

## Правила рендера для условий

```
if (условие) {
    блоки_да
};
else {
    блоки_нет
};
следующий_блок
```

- Блок условия находится на главной линии
- Блоки ветки ДА рендерятся **ниже** блока условия (по главной линии)
- Блоки ветки НЕТ (else) рендерятся **сбоку** от блока условия
- После обеих веток управление сходится на `следующий_блок`
- Если `else` нет — линия НЕТ напрямую идёт к `следующий_блок`

---

## Правила рендера для циклов

```
while (условие) {
    тело
};
следующий_блок
```

- Блок условия на главной линии
- Тело цикла **ниже** блока условия, подключено от ноды ДА
- Из последнего блока тела стрелка уходит **вверх** к блоку условия (обратная стрелка)
- Ветка НЕТ идёт к `следующий_блок`

---

## Пример: трансляция while

**Bock:**
```bock
function exp_while {
    i = 10;
    while (i != 0) {
        output >> "i";
        i = i - 1;
    };
    output >> "done";
}
```

**Порядок блоков в `blocks[]`:**

| Индекс | Тип | Текст |
|---|---|---|
| 0 | Начало / конец | Начало |
| 1 | Блок | i = 10 |
| 2 | Условие | i != 0 |
| 3 | Ввод / вывод | i |
| 4 | Блок | i = i - 1 |
| 5 | Ввод / вывод | done |
| 6 | Начало / конец | Конец |

**Стрелки:**

| От | До | Комментарий |
|---|---|---|
| 0 → 1 | низ → верх | обычный переход |
| 1 → 2 | низ → верх | обычный переход |
| 2 → 3 | низ → верх | ветка ДА |
| 3 → 4 | низ → верх | тело цикла |
| 4 → 2 | низ → верх | обратная стрелка цикла |
| 2 → 5 | лево/право → верх | ветка НЕТ |
| 5 → 6 | низ → верх | обычный переход |

---
